#!/usr/bin/env python3

# For the latest information about this program (GPLv3 license), see:
#
#     https://github.com/willemw12/xmltv2rss
#

import argparse
import io
import os.path
import sys
import xml.etree.ElementTree as ElementTree

from datetime import datetime, timezone

# RFC-2822 formatted datetime
from email import utils
# from xml.dom.minidom import parseString
# from xml.etree.ElementTree import ElementTree

# DEFAULT_XML_INDENT=2

# Datetime with timezone
DEFAULT_XMLTV_DATETIME_FORMAT = "%Y%m%d%H%M%S %z"
# Datetime without timezone
DEFAULT_XMLTV_DATETIME_FORMAT_UTC = "%Y%m%d%H%M%S"

DEFAULT_FEED_DESCRIPTION = "Generated by xmltv2rss"
DEFAULT_FEED_LANGUAGE = "en"
DEFAULT_FEED_LINK = ""
DEFAULT_FEED_TITLE = "XMLTV feed"

DEFAULT_FEED_DATE_FORMAT = "%a %d %B, %Y"
DEFAULT_FEED_TIME_FORMAT = "%H:%M"


def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate an RSS feed from an XMLTV TV listing. Print the result to standard output.",
        epilog='For information about date and time format strings ("%Y", "%H", etc.), search for "datetime" on https://docs.python.org.',
    )
    parser.add_argument(
        "--feed-date-format",
        "-d",
        nargs=1,
        default=[DEFAULT_FEED_DATE_FORMAT],
        help='RSS feed date format. Examples: "%%Y-%%m-%%d", "%%a %%d %%B, %%Y", "%%x"',
    )
    parser.add_argument(
        "--feed-language",
        default=DEFAULT_FEED_LANGUAGE,
        help='RSS feed language. Default: "' + DEFAULT_FEED_LANGUAGE + '"',
    )
    parser.add_argument(
        "--feed-link",
        default="",
        help='RSS feed URL. Default: ""',
    )
    parser.add_argument(
        "--feed-time-format",
        "-t",
        nargs=1,
        default=[DEFAULT_FEED_TIME_FORMAT],
        help='RSS feed time format. Examples: "%%H:%%M", "%%I:%%M %%p", "%%X"',
    )
    parser.add_argument(
        "--feed-title", default=DEFAULT_FEED_TITLE, help="RSS feed title"
    )
    # parser.add_argument(
    #    "--indent",
    #    action="store_const",
    #    const=True,
    #    default=DEFAULT_XML_INDENT,
    #    help="RSS feed indentation",
    # )
    parser.add_argument(
        "--xmltv-datetime-format",
        nargs=1,
        default=DEFAULT_XMLTV_DATETIME_FORMAT,
        help='XMLTV date and time format. Default: "'
        + DEFAULT_XMLTV_DATETIME_FORMAT.replace("%", "%%")
        + '". Default fallback: "'
        + DEFAULT_XMLTV_DATETIME_FORMAT_UTC.replace("%", "%%")
        + '"',
    )
    parser.add_argument(
        "input_filename",
        metavar="<file>",
        nargs="?",
        default=sys.stdin,
        help="XMLTV input filename. Default: read from standard input",
    )
    parser.set_defaults(feed_description=DEFAULT_FEED_DESCRIPTION)

    args = parser.parse_args()
    return args


def run(args):
    # try:

    # from xml.etree.ElementTree import ElementTree
    # xmltv_listing = ElementTree()
    # xmltv_listing.parse(args.input_filename)
    xmltv_listing = ElementTree.parse(args.input_filename)

    # except xml.etree.ElementTree.ParseError as exc:
    #    ...

    created_on = utils.format_datetime(datetime.now())
    if isinstance(args.input_filename, str):
        # Get modification time from the input file
        timestamp = os.path.getmtime(args.input_filename)
        pub_date = utils.formatdate(timestamp, localtime=True)
    else:
        pub_date = utils.formatdate(localtime=True)

    rss_feed = convert_listing(args, created_on, pub_date, xmltv_listing)

    rss_feed.write(sys.stdout, encoding="unicode")

    # indent = args.indent
    #
    # rss_tree_str = xml.etree.ElementTree.tostring(rss_feed.getroot(), encoding='unicode')
    # print(parseString(rss_tree_str).toprettyxml(indent='  ', newl='\n'))


def convert_listing(args, created_on, pub_date, xmltv_listing):
    RSS_CHANNEL_TEMPLATE = """<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
  <channel>
    <title>%(title)s</title>
    <link>%(link)s</link>
    <description>%(description)s</description>
    <language>%(language)s</language>
    <pubDate>%(pub_date)s</pubDate>
    <lastBuildDate>%(created_on)s</lastBuildDate>
  </channel>
</rss>
"""

    # For pretty output
    RSS_ITEM_HEAD_TEMPLATE = """
    """

    # For pretty output
    RSS_ITEM_TAIL_TEMPLATE = """
  """

    rss_feed = ElementTree.ElementTree()

    rss_channel_dict = dict(
        title=args.feed_title,
        link=args.feed_link if args.feed_link else "",
        description=args.feed_description,
        pub_date=pub_date,
        created_on=created_on,
        language=args.feed_language,
    )
    rss_channel_str = RSS_CHANNEL_TEMPLATE % rss_channel_dict

    # rss_feed.parse('rss_channel_template.xml')
    rss_feed.parse(io.StringIO(rss_channel_str))

    rss_channel = rss_feed.find("channel")
    if rss_channel is None:
        return rss_feed

    # For pretty output
    #
    # TODO: Return the last child, not the first child
    # last_child = channel.find('*[last()]')
    #
    # last_child = channel.find('language')
    children = rss_channel.findall("*")
    last_child = children[len(children) - 1]
    last_child.tail = RSS_ITEM_HEAD_TEMPLATE

    # xmltv_programmes = iterfind('programme')
    xmltv_programmes = xmltv_listing.findall("programme")
    if xmltv_programmes is None:
        return rss_feed

    for i, xmltv_programme in enumerate(xmltv_programmes):
        rss_item = convert_programme(args, xmltv_listing, xmltv_programme)

        # For pretty output
        if i < len(xmltv_programmes) - 1:
            rss_item.tail = RSS_ITEM_HEAD_TEMPLATE
        else:
            rss_item.tail = RSS_ITEM_TAIL_TEMPLATE

        rss_channel.append(rss_item)

    return rss_feed


def convert_programme(args, xmltv_listing, xmltv_programme):
    RSS_ITEM_TEMPLATE = """
    <item>
      <title><![CDATA[%(title)s]]></title>
      <link></link>
      <description><![CDATA[%(description)s]]></description>
      <guid>%(guid)s</guid>
      <pubDate>%(pub_date)s</pubDate>
    </item>
"""

    RSS_ITEM_DESCRIPTION_TEMPLATE = """
         <table>
            <tr><td align="right" valign="top">Title:</td><td>%(title)s</td></tr>
            <tr><td align="right" valign="top">Channel:</td><td>%(channel)s</td></tr>
            <tr><td align="right" valign="top">Airdate:</td><td>%(airdate)s</td></tr>
            <tr><td align="right" valign="top">Airtime:</td><td>%(airtime)s</td></tr>
            <tr><td align="right" valign="top" style="white-space: nowrap">Length:</td><td>%(airtime_length)s</td></tr>
            <tr><td align="right" valign="top">Category:</td><td>%(category)s</td></tr>
            <tr><td align="right" valign="top">Description:</td><td>%(desc)s</td></tr>
         </table>
      """

    channel_id = xmltv_programme.get("channel", default="")
    title = xmltv_programme.findtext("title", default="")
    desc = xmltv_programme.findtext("desc", default="")
    category = xmltv_programme.findtext("category", default="")

    starttime = xmltv_programme.get("start", default="")
    stoptime = xmltv_programme.get("stop", default=starttime)

    channel_callsign = xmltv_listing.findtext(
        "./channel[@id='" + channel_id + "']/display-name"
    )
    if channel_callsign:
        channel = "{}-{}".format(channel_id, channel_callsign)
    else:
        channel = "{}".format(channel_id)

    # Datetime is either with timezone ("YYYYMMDDHHMMSS Â±HHMM")
    # or without timezone ("YYYYMMDDHHMMSS", UTC timezone assumed)
    try:
        starttime_dt = datetime.strptime(starttime, args.xmltv_datetime_format)
    except ValueError:
        starttime_dt = datetime.strptime(
            starttime, DEFAULT_XMLTV_DATETIME_FORMAT_UTC
        ).replace(tzinfo=timezone.utc)
    try:
        stoptime_dt = datetime.strptime(stoptime, args.xmltv_datetime_format)
    except ValueError:
        stoptime_dt = datetime.strptime(
            stoptime, DEFAULT_XMLTV_DATETIME_FORMAT_UTC
        ).replace(tzinfo=timezone.utc)

    # Set start and stop time to local timezone.
    # airdate and airtime will be displayed in local, not the original, timezone.
    # No need to import tzlocal when using .astimezone().
    starttime_dt = starttime_dt.astimezone()
    stoptime_dt = stoptime_dt.astimezone()

    airdate = datetime.strftime(starttime_dt, args.feed_date_format[0])
    airtime = (
        datetime.strftime(starttime_dt, args.feed_time_format[0])
        + " - "
        + datetime.strftime(stoptime_dt, args.feed_time_format[0])
    )

    # Airtime length in hours and minutes
    airtime_length_td = stoptime_dt - starttime_dt
    airtime_length_mins = airtime_length_td.seconds // 60
    airtime_length = (
        "{0:2}".format(airtime_length_mins // 60)
        + ":"
        + "{0:02}".format(airtime_length_mins % 60)
        + ":00"
    )

    # XMLTV EPG <desc/> may contain newlines. Replace them with <br/> for pretty print output
    desc = desc.strip()
    desc = "<br/>".join(line.strip() for line in desc.splitlines())

    GUID_DATETIME_FORMAT = "%Y%m%d%H%M%S"
    guid = channel_id + "-" + starttime_dt.strftime(GUID_DATETIME_FORMAT)
    pub_date = utils.formatdate(starttime_dt.timestamp(), localtime=True)

    description_dict = dict(
        title=title,
        channel=channel,
        airdate=airdate,
        airtime=airtime,
        airtime_length=airtime_length,
        desc=desc,
        category=category,
    )
    description_str = RSS_ITEM_DESCRIPTION_TEMPLATE % description_dict

    rss_item_dict = dict(
        title=title,
        # sub_title=sub_title,
        # link=link,
        description=description_str,
        guid=guid,
        pub_date=pub_date,
    )
    rss_item_str = RSS_ITEM_TEMPLATE % rss_item_dict

    rss_item = ElementTree.fromstring(rss_item_str)
    return rss_item


def main():
    args = parse_args()
    run(args)


if __name__ == "__main__":
    main()
